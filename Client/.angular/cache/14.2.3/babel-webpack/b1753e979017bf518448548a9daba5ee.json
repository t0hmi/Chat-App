{"ast":null,"code":"import _asyncToGenerator from \"C:/thomashamon_perso/authentification/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\n// Licensed to the .NET Foundation under one or more agreements.\n// The .NET Foundation licenses this file to you under the MIT license.\nimport { AbortError, HttpError, TimeoutError } from \"./Errors\";\nimport { HttpClient, HttpResponse } from \"./HttpClient\";\nimport { LogLevel } from \"./ILogger\";\nimport { Platform, getGlobalThis } from \"./Utils\";\nexport class FetchHttpClient extends HttpClient {\n  constructor(logger) {\n    super();\n    this._logger = logger;\n\n    if (typeof fetch === \"undefined\") {\n      // In order to ignore the dynamic require in webpack builds we need to do this magic\n      // @ts-ignore: TS doesn't know about these names\n      const requireFunc = typeof __webpack_require__ === \"function\" ? __non_webpack_require__ : require; // Cookies aren't automatically handled in Node so we need to add a CookieJar to preserve cookies across requests\n\n      this._jar = new (requireFunc(\"tough-cookie\").CookieJar)();\n      this._fetchType = requireFunc(\"node-fetch\"); // node-fetch doesn't have a nice API for getting and setting cookies\n      // fetch-cookie will wrap a fetch implementation with a default CookieJar or a provided one\n\n      this._fetchType = requireFunc(\"fetch-cookie\")(this._fetchType, this._jar);\n    } else {\n      this._fetchType = fetch.bind(getGlobalThis());\n    }\n\n    if (typeof AbortController === \"undefined\") {\n      // In order to ignore the dynamic require in webpack builds we need to do this magic\n      // @ts-ignore: TS doesn't know about these names\n      const requireFunc = typeof __webpack_require__ === \"function\" ? __non_webpack_require__ : require; // Node needs EventListener methods on AbortController which our custom polyfill doesn't provide\n\n      this._abortControllerType = requireFunc(\"abort-controller\");\n    } else {\n      this._abortControllerType = AbortController;\n    }\n  }\n  /** @inheritDoc */\n\n\n  send(request) {\n    var _this = this;\n\n    return _asyncToGenerator(function* () {\n      // Check that abort was not signaled before calling send\n      if (request.abortSignal && request.abortSignal.aborted) {\n        throw new AbortError();\n      }\n\n      if (!request.method) {\n        throw new Error(\"No method defined.\");\n      }\n\n      if (!request.url) {\n        throw new Error(\"No url defined.\");\n      }\n\n      const abortController = new _this._abortControllerType();\n      let error; // Hook our abortSignal into the abort controller\n\n      if (request.abortSignal) {\n        request.abortSignal.onabort = () => {\n          abortController.abort();\n          error = new AbortError();\n        };\n      } // If a timeout has been passed in, setup a timeout to call abort\n      // Type needs to be any to fit window.setTimeout and NodeJS.setTimeout\n\n\n      let timeoutId = null;\n\n      if (request.timeout) {\n        const msTimeout = request.timeout;\n        timeoutId = setTimeout(() => {\n          abortController.abort();\n\n          _this._logger.log(LogLevel.Warning, `Timeout from HTTP request.`);\n\n          error = new TimeoutError();\n        }, msTimeout);\n      }\n\n      let response;\n\n      try {\n        response = yield _this._fetchType(request.url, {\n          body: request.content,\n          cache: \"no-cache\",\n          credentials: request.withCredentials === true ? \"include\" : \"same-origin\",\n          headers: {\n            \"Content-Type\": \"text/plain;charset=UTF-8\",\n            \"X-Requested-With\": \"XMLHttpRequest\",\n            ...request.headers\n          },\n          method: request.method,\n          mode: \"cors\",\n          redirect: \"follow\",\n          signal: abortController.signal\n        });\n      } catch (e) {\n        if (error) {\n          throw error;\n        }\n\n        _this._logger.log(LogLevel.Warning, `Error from HTTP request. ${e}.`);\n\n        throw e;\n      } finally {\n        if (timeoutId) {\n          clearTimeout(timeoutId);\n        }\n\n        if (request.abortSignal) {\n          request.abortSignal.onabort = null;\n        }\n      }\n\n      if (!response.ok) {\n        const errorMessage = yield deserializeContent(response, \"text\");\n        throw new HttpError(errorMessage || response.statusText, response.status);\n      }\n\n      const content = deserializeContent(response, request.responseType);\n      const payload = yield content;\n      return new HttpResponse(response.status, response.statusText, payload);\n    })();\n  }\n\n  getCookieString(url) {\n    let cookies = \"\";\n\n    if (Platform.isNode && this._jar) {\n      // @ts-ignore: unused variable\n      this._jar.getCookies(url, (e, c) => cookies = c.join(\"; \"));\n    }\n\n    return cookies;\n  }\n\n}\n\nfunction deserializeContent(response, responseType) {\n  let content;\n\n  switch (responseType) {\n    case \"arraybuffer\":\n      content = response.arrayBuffer();\n      break;\n\n    case \"text\":\n      content = response.text();\n      break;\n\n    case \"blob\":\n    case \"document\":\n    case \"json\":\n      throw new Error(`${responseType} is not supported.`);\n\n    default:\n      content = response.text();\n      break;\n  }\n\n  return content;\n}","map":{"version":3,"names":["AbortError","HttpError","TimeoutError","HttpClient","HttpResponse","LogLevel","Platform","getGlobalThis","FetchHttpClient","constructor","logger","_logger","fetch","requireFunc","__webpack_require__","__non_webpack_require__","require","_jar","CookieJar","_fetchType","bind","AbortController","_abortControllerType","send","request","abortSignal","aborted","method","Error","url","abortController","error","onabort","abort","timeoutId","timeout","msTimeout","setTimeout","log","Warning","response","body","content","cache","credentials","withCredentials","headers","mode","redirect","signal","e","clearTimeout","ok","errorMessage","deserializeContent","statusText","status","responseType","payload","getCookieString","cookies","isNode","getCookies","c","join","arrayBuffer","text"],"sources":["C:/thomashamon_perso/authentification/node_modules/@microsoft/signalr/dist/esm/FetchHttpClient.js"],"sourcesContent":["// Licensed to the .NET Foundation under one or more agreements.\r\n// The .NET Foundation licenses this file to you under the MIT license.\r\nimport { AbortError, HttpError, TimeoutError } from \"./Errors\";\r\nimport { HttpClient, HttpResponse } from \"./HttpClient\";\r\nimport { LogLevel } from \"./ILogger\";\r\nimport { Platform, getGlobalThis } from \"./Utils\";\r\nexport class FetchHttpClient extends HttpClient {\r\n    constructor(logger) {\r\n        super();\r\n        this._logger = logger;\r\n        if (typeof fetch === \"undefined\") {\r\n            // In order to ignore the dynamic require in webpack builds we need to do this magic\r\n            // @ts-ignore: TS doesn't know about these names\r\n            const requireFunc = typeof __webpack_require__ === \"function\" ? __non_webpack_require__ : require;\r\n            // Cookies aren't automatically handled in Node so we need to add a CookieJar to preserve cookies across requests\r\n            this._jar = new (requireFunc(\"tough-cookie\")).CookieJar();\r\n            this._fetchType = requireFunc(\"node-fetch\");\r\n            // node-fetch doesn't have a nice API for getting and setting cookies\r\n            // fetch-cookie will wrap a fetch implementation with a default CookieJar or a provided one\r\n            this._fetchType = requireFunc(\"fetch-cookie\")(this._fetchType, this._jar);\r\n        }\r\n        else {\r\n            this._fetchType = fetch.bind(getGlobalThis());\r\n        }\r\n        if (typeof AbortController === \"undefined\") {\r\n            // In order to ignore the dynamic require in webpack builds we need to do this magic\r\n            // @ts-ignore: TS doesn't know about these names\r\n            const requireFunc = typeof __webpack_require__ === \"function\" ? __non_webpack_require__ : require;\r\n            // Node needs EventListener methods on AbortController which our custom polyfill doesn't provide\r\n            this._abortControllerType = requireFunc(\"abort-controller\");\r\n        }\r\n        else {\r\n            this._abortControllerType = AbortController;\r\n        }\r\n    }\r\n    /** @inheritDoc */\r\n    async send(request) {\r\n        // Check that abort was not signaled before calling send\r\n        if (request.abortSignal && request.abortSignal.aborted) {\r\n            throw new AbortError();\r\n        }\r\n        if (!request.method) {\r\n            throw new Error(\"No method defined.\");\r\n        }\r\n        if (!request.url) {\r\n            throw new Error(\"No url defined.\");\r\n        }\r\n        const abortController = new this._abortControllerType();\r\n        let error;\r\n        // Hook our abortSignal into the abort controller\r\n        if (request.abortSignal) {\r\n            request.abortSignal.onabort = () => {\r\n                abortController.abort();\r\n                error = new AbortError();\r\n            };\r\n        }\r\n        // If a timeout has been passed in, setup a timeout to call abort\r\n        // Type needs to be any to fit window.setTimeout and NodeJS.setTimeout\r\n        let timeoutId = null;\r\n        if (request.timeout) {\r\n            const msTimeout = request.timeout;\r\n            timeoutId = setTimeout(() => {\r\n                abortController.abort();\r\n                this._logger.log(LogLevel.Warning, `Timeout from HTTP request.`);\r\n                error = new TimeoutError();\r\n            }, msTimeout);\r\n        }\r\n        let response;\r\n        try {\r\n            response = await this._fetchType(request.url, {\r\n                body: request.content,\r\n                cache: \"no-cache\",\r\n                credentials: request.withCredentials === true ? \"include\" : \"same-origin\",\r\n                headers: {\r\n                    \"Content-Type\": \"text/plain;charset=UTF-8\",\r\n                    \"X-Requested-With\": \"XMLHttpRequest\",\r\n                    ...request.headers,\r\n                },\r\n                method: request.method,\r\n                mode: \"cors\",\r\n                redirect: \"follow\",\r\n                signal: abortController.signal,\r\n            });\r\n        }\r\n        catch (e) {\r\n            if (error) {\r\n                throw error;\r\n            }\r\n            this._logger.log(LogLevel.Warning, `Error from HTTP request. ${e}.`);\r\n            throw e;\r\n        }\r\n        finally {\r\n            if (timeoutId) {\r\n                clearTimeout(timeoutId);\r\n            }\r\n            if (request.abortSignal) {\r\n                request.abortSignal.onabort = null;\r\n            }\r\n        }\r\n        if (!response.ok) {\r\n            const errorMessage = await deserializeContent(response, \"text\");\r\n            throw new HttpError(errorMessage || response.statusText, response.status);\r\n        }\r\n        const content = deserializeContent(response, request.responseType);\r\n        const payload = await content;\r\n        return new HttpResponse(response.status, response.statusText, payload);\r\n    }\r\n    getCookieString(url) {\r\n        let cookies = \"\";\r\n        if (Platform.isNode && this._jar) {\r\n            // @ts-ignore: unused variable\r\n            this._jar.getCookies(url, (e, c) => cookies = c.join(\"; \"));\r\n        }\r\n        return cookies;\r\n    }\r\n}\r\nfunction deserializeContent(response, responseType) {\r\n    let content;\r\n    switch (responseType) {\r\n        case \"arraybuffer\":\r\n            content = response.arrayBuffer();\r\n            break;\r\n        case \"text\":\r\n            content = response.text();\r\n            break;\r\n        case \"blob\":\r\n        case \"document\":\r\n        case \"json\":\r\n            throw new Error(`${responseType} is not supported.`);\r\n        default:\r\n            content = response.text();\r\n            break;\r\n    }\r\n    return content;\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}